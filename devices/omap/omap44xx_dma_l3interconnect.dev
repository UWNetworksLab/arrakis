/*
 * Copyright (c) 2013 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
 * Attn: Systems Group.
 */

/*
 * omap44xx_dma_l3interconnect.dev
 *
 * DESCRIPTION: 
 *
 * NOTE: This file has been automatically generated based on the
 * XML files extracted from the TI RDT v1.0.0.4p Tool.
 * Download from here: http://www.ti.com/product/omap4460
 * This means that the file might not be optimal in terms of naming
 * conventions for constants and registers (duplicated
 * namespaces in register and device name etc.).
 * Also, because of the underlying structure from the original XML
 * it's possible that some constants appear multiple times (if they
 * have slightly different descriptions for example).
 *
 * You want to clean that up before using the files for the first time!
 */
 
device omap44xx_dma_l3interconnect msbfirst ( addr base ) "" {
    
    
    register simcop_dma_revision ro addr(base, 0x0) "IP Revision Identifier (X.Y.R) Used by software to track features, bugs, and compatibility." type(uint32);

    constants chan_status width(1) "" {
        CHAN_0_r = 0 "4";
        CHAN_1_r = 1 "8";
    };

    constants context_status width(2) "" {
        CONTEXT_0_r = 0 "4";
        CONTEXT_1_r = 1 "8";
        CONTEXT_2_r = 2 "16";
    };
    
    register simcop_dma_hwinfo addr(base, 0x4) "Information about the IP module's hardware configuration, that is, typically the module's HDL generics." {
        _ 29 mbz;
        chan 1 ro type(chan_status) "Logical channels";
        context 2 ro type(context_status) "Maximum outstanding OCP transactions";
    };

    constants standbymode_status width(2) "" {
        STANDBYMODE_0 = 0 "Force-standby mode: local initiator is unconditionally placed in standby state. Backup mode, for debug only.";
        STANDBYMODE_1 = 1 "No-standby mode: local initiator is unconditionally placed out of standby state. Backup mode, for debug only.";
        STANDBYMODE_2 = 2 "Smart-standby mode.";
        STANDBYMODE_3 = 3 "Smart-standby mode.";
    };
    
    register simcop_dma_sysconfig addr(base, 0x10) "Clock management configuration" {
        _ 26 mbz;
        standbymode 2 rw type(standbymode_status) "Configuration of the local initiator state management mode. By definition, initiator may generate read/write transaction as long as it is out of STANDBY state.";
        _ 4 mbz;
    };

    constants posted_writes_status width(1) "" {
        POSTED_WRITES_0 = 0 "Only nonposted writes are generated";
        POSTED_WRITES_1 = 1 "Only posted writes are generated";
    };

    constants max_burst_size_status width(2) "" {
        MAX_BURST_SIZE_0 = 0 "Single requests only";
        MAX_BURST_SIZE_1 = 1 "less or equal to 2";
        MAX_BURST_SIZE_2 = 2 "less or equal to 4";
        MAX_BURST_SIZE_3 = 3 "less or equal to 8";
    };
    
    register simcop_dma_ctrl addr(base, 0x1C) "" {
        bw_limiter 16 rw "SIMCOP DMA guarantees that there are at least BW_LIMITER functional clock cycles between two OCP requests. No IDLE cycles are inserted during an OCP transaction. This parameter could be used to reduce traffic generated by the SIMCOP DMA for non timing critical applications. Doing so leaves more BW for other system initiators. Default value corresponds to maximum performance.";
        _ 8 mbz;
        tag_cnt 4 rw "Limits the outstanding transactions count. Only tags 0 - TAG_CNT will be used by SIMCOP DMA The maximum allowed value is 2";
        posted_writes 1 rw type(posted_writes_status) "Select write type. Setting depend on the used interconnect";
        _ 1 mbz;
        max_burst_size 2 rw type(max_burst_size_status) "Defines the maximum burst length for INCR bursts. In case of 2D bursts, length x height is less or equal to this value.";
    };

    constants chan7_frame_done_irq_status width(1) "" {
        CHAN7_FRAME_DONE_IRQ_0_w = 0 "No action";
        CHAN7_FRAME_DONE_IRQ_0_r = 0 "No event pending";
        CHAN7_FRAME_DONE_IRQ_1_r = 1 "Event pending";
        CHAN7_FRAME_DONE_IRQ_1_w = 1 "Set event (debug)";
    };
    
    register simcop_dma_irqstatus_raw_j_0 addr(base, 0x20) "Per-event raw interrupt status vector Raw status is set even if event is not enabled. Write 1 to set the (raw) status, mostly for debug." {
        chan7_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        ocp_err 1 rw type(chan7_frame_done_irq_status) "OCP error";
    };
    
    register simcop_dma_irqstatus_raw_j_1 addr(base, 0x30) "Per-event raw interrupt status vector Raw status is set even if event is not enabled. Write 1 to set the (raw) status, mostly for debug." {
        chan7_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw type(chan7_frame_done_irq_status) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        ocp_err 1 rw type(chan7_frame_done_irq_status) "OCP error";
    };

    constants chan7_frame_done_irq_status1 width(1) "" {
        CHAN7_FRAME_DONE_IRQ_0_w_2 = 0 "No action";
        CHAN7_FRAME_DONE_IRQ_0_r_2 = 0 "No (enabled) event pending";
        CHAN7_FRAME_DONE_IRQ_1_r_2 = 1 "Event pending";
        CHAN7_FRAME_DONE_IRQ_1_w_2 = 1 "Clear (raw) event";
    };
    
    register simcop_dma_irqstatus_j_0 addr(base, 0x24) "Per-event 'enabled' interrupt status vector Enabled status is not set unless event is enabled. Write 1 to clear the status after interrupt has been serviced (raw status gets cleared, that is, even if not enabled)." {
        chan7_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        bus_err 1 rw1c type(chan7_frame_done_irq_status1) "BUS error";
    };
    
    register simcop_dma_irqstatus_j_1 addr(base, 0x34) "Per-event 'enabled' interrupt status vector Enabled status is not set unless event is enabled. Write 1 to clear the status after interrupt has been serviced (raw status gets cleared, that is, even if not enabled)." {
        chan7_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw1c type(chan7_frame_done_irq_status1) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        bus_err 1 rw1c type(chan7_frame_done_irq_status1) "BUS error";
    };

    constants chan7_frame_done_irq_status2 width(1) "" {
        CHAN7_FRAME_DONE_IRQ_0_w_4 = 0 "No action";
        CHAN7_FRAME_DONE_IRQ_0_r_4 = 0 "Interrupt disabled (masked)";
        CHAN7_FRAME_DONE_IRQ_1_r_4 = 1 "Interrupt enabled";
        CHAN7_FRAME_DONE_IRQ_1_w_4 = 1 "Enable interrupt";
    };
    
    register simcop_dma_irqenable_set_j_0 addr(base, 0x28) "Per-event interrupt enable bit vector Write 1 to set (enable interrupt). Readout equal to corresponding _CLR register." {
        chan7_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        ocp_err 1 rw type(chan7_frame_done_irq_status2) "OCP error";
    };
    
    register simcop_dma_irqenable_set_j_1 addr(base, 0x38) "Per-event interrupt enable bit vector Write 1 to set (enable interrupt). Readout equal to corresponding _CLR register." {
        chan7_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw type(chan7_frame_done_irq_status2) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        ocp_err 1 rw type(chan7_frame_done_irq_status2) "OCP error";
    };

    constants chan7_frame_done_irq_status3 width(1) "" {
        CHAN7_FRAME_DONE_IRQ_0_w_6 = 0 "No action";
        CHAN7_FRAME_DONE_IRQ_0_r_6 = 0 "Interrupt disabled (masked)";
        CHAN7_FRAME_DONE_IRQ_1_r_6 = 1 "Interrupt enabled";
        CHAN7_FRAME_DONE_IRQ_1_w_6 = 1 "Disable interrupt";
    };
    
    register simcop_dma_irqenable_clr_j_0 addr(base, 0x2C) "Per-event interrupt enable bit vector Write 1 to clear (disable interrupt). Readout equal to corresponding _SET register." {
        chan7_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        ocp_err 1 rw1c type(chan7_frame_done_irq_status3) "OCP error";
    };
    
    register simcop_dma_irqenable_clr_j_1 addr(base, 0x3C) "Per-event interrupt enable bit vector Write 1 to clear (disable interrupt). Readout equal to corresponding _SET register." {
        chan7_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan6_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan5_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan4_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan3_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan2_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan1_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan0_frame_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of the full frame";
        chan7_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan6_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan5_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan4_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan3_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan2_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan1_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        chan0_block_done_irq 1 rw1c type(chan7_frame_done_irq_status3) "Channel has completed transfer of one 2D block";
        _ 15 mbz;
        ocp_err 1 rw1c type(chan7_frame_done_irq_status3) "OCP error";
    };

    constants hwstop_status width(3) "" {
        HWSTOP_0 = 0 "Disabled.";
        HWSTOP_4 = 4 "Use hardware synchronization channel 0";
        HWSTOP_5 = 5 "Use hardware synchronization channel 1";
        HWSTOP_6 = 6 "Use hardware synchronization channel 2";
        HWSTOP_7 = 7 "Use hardware synchronization channel 3";
    };

    constants linked_status width(5) "" {
        LINKED_0 = 0 "Disabled.";
        LINKED_16 = 16 "Start channel 0 when this channel has completed transfer of one 2D block";
        LINKED_17 = 17 "Start channel 1 when this channel has completed transfer of one 2D block";
        LINKED_18 = 18 "Start channel 2 when this channel has completed transfer of one 2D block";
        LINKED_19 = 19 "Start channel 3 when this channel has completed transfer of one 2D block";
        LINKED_20 = 20 "Start channel 4 when this channel has completed transfer of one 2D block";
        LINKED_21 = 21 "Start channel 5 when this channel has completed transfer of one 2D block";
        LINKED_22 = 22 "Start channel 6 when this channel has completed transfer of one 2D block";
        LINKED_23 = 23 "Start channel 7 when this channel has completed transfer of one 2D block";
    };

    constants tilermode_status width(1) "" {
        TILERMODE_0 = 0 "Regular mode. INCR burst are used. ADDR[32]=0 for OCP transactions";
        TILERMODE_1 = 1 "Tiler mode. BLCK burst are used. ADDR[32]=1 for OCP transactions";
    };

    constants dir_status width(1) "" {
        DIR_0 = 0 "System memory - SIMCOP buffers";
        DIR_1 = 1 "SIMCOP buffers - system memory";
    };

    constants status_status width(2) "" {
        STATUS_0_r = 0 "Idle";
        STATUS_1_r = 1 "Active";
        STATUS_2_r = 2 "Pending";
        STATUS_3_r = 3 "Running";
    };

    constants swtrigger_status width(1) "" {
        SWTRIGGER_0_w = 0 "No effect";
        SWTRIGGER_1_w = 1 "Change the logical channel state to PENDING if it is in ACTIVE state. No effect if the channel is in RUNNING, PENDING or IDLE state";
    };

    constants disable_status width(1) "" {
        DISABLE_0_w = 0 "No effect.";
        DISABLE_1_w = 1 "Disable the channel. Changes the logical channel state to IDLE when it is in ACTIVE state. Memorize a disable request when the channel is in RUNNING or PENDING state.";
    };

    constants enable_status width(1) "" {
        ENABLE_0_w = 0 "No effect";
        ENABLE_1_w = 1 "Enable the channel. Changes the state of the logical channel from IDLE to ACTIVE.";
    };
    
    register simcop_dma_chan_ctrl_i_0 addr(base, 0x80) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_1 addr(base, 0xB0) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_2 addr(base, 0xE0) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_3 addr(base, 0x110) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_4 addr(base, 0x140) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_5 addr(base, 0x170) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_6 addr(base, 0x1A0) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_ctrl_i_7 addr(base, 0x1D0) "Logical channel control register" {
        _ 9 mbz;
        hwstop 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls generation of the DONE pulse for the logical channel Only the values listed below are allowed. Other values lead to undefined behavior.";
        hwstart 3 rw type(hwstop_status) "DMA logical channel hardware synchronization. Controls sensitivity of the logical channel on a START pulse Only the values listed below are allowed. Other values lead to undefined behavior.";
        linked 5 rw type(linked_status) "DMA logical channel linking. Only the values listed below are allowed. Other values lead to undefined behavior.";
        _ 5 mbz;
        tilermode 1 rw type(tilermode_status) "Selects OCP transaction breakdown algorithm";
        dir 1 rw type(dir_status) "Transfer direction";
        status 2 ro type(status_status) "SW could poll this bit to know the state of the channel";
        swtrigger 1 wo type(swtrigger_status) "Software trigger of the DMA channel. Read of this register always returns 0.";
        disable 1 wo type(disable_status) "Disable control of the logical channel. Read of this register always returns 0.";
        enable 1 wo type(enable_status) "Enable control of the logical channel. Read of this register always returns 0.";
    };
    
    register simcop_dma_chan_smem_addr_i_0 addr(base, 0x84) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_1 addr(base, 0xB4) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_2 addr(base, 0xE4) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_3 addr(base, 0x114) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_4 addr(base, 0x144) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_5 addr(base, 0x174) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_6 addr(base, 0x1A4) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_addr_i_7 addr(base, 0x1D4) "System memory address" {
        addr 28 rw "Address in 128-bit words";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_0 addr(base, 0x88) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_1 addr(base, 0xB8) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_2 addr(base, 0xE8) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_3 addr(base, 0x118) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_4 addr(base, 0x148) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_5 addr(base, 0x178) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_6 addr(base, 0x1A8) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_smem_ofst_i_7 addr(base, 0x1D8) "System memory line offset in 128-bit words. Maximum stride = 1MB" {
        _ 12 mbz;
        ofst 16 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_0 addr(base, 0x8C) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_1 addr(base, 0xBC) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_2 addr(base, 0xEC) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_3 addr(base, 0x11C) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_4 addr(base, 0x14C) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_5 addr(base, 0x17C) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_6 addr(base, 0x1AC) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_ofst_i_7 addr(base, 0x1DC) "SIMCOP memory line offset" {
        _ 8 mbz;
        ofst 20 rw "Line offset. In 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_0 addr(base, 0x90) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_1 addr(base, 0xC0) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_2 addr(base, 0xF0) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_3 addr(base, 0x120) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_4 addr(base, 0x150) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_5 addr(base, 0x180) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_6 addr(base, 0x1B0) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_buf_addr_i_7 addr(base, 0x1E0) "SIMCOP memory address" {
        _ 8 mbz;
        addr 20 rw "Address in 128-bit words.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_0 addr(base, 0x94) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_1 addr(base, 0xC4) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_2 addr(base, 0xF4) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_3 addr(base, 0x124) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_4 addr(base, 0x154) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_5 addr(base, 0x184) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_6 addr(base, 0x1B4) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_size_i_7 addr(base, 0x1E4) "2D block size" {
        _ 3 mbz;
        ynum 13 rw "Height, in lines, per 2D block Valid values are 1- 8191.";
        _ 2 mbz;
        xnum 10 rw "Width, in 128-bit words, per 2D block. Valid values are 1-1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_frame_i_0 addr(base, 0x98) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_1 addr(base, 0xC8) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_2 addr(base, 0xF8) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_3 addr(base, 0x128) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_4 addr(base, 0x158) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_5 addr(base, 0x188) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_6 addr(base, 0x1B8) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_frame_i_7 addr(base, 0x1E8) "Defines a frame. A frame is composed of 2D blocks." {
        _ 6 mbz;
        ycnt 10 rw "Vertical count of 2D blocks per frame. Valid values are 1-1023";
        _ 6 mbz;
        xcnt 10 rw "Horizontal count of 2D blocks per frame. Valid values are 1-1023";
    };
    
    register simcop_dma_chan_current_block_i_0 addr(base, 0xA0) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_1 addr(base, 0xD0) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_2 addr(base, 0x100) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_3 addr(base, 0x130) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_4 addr(base, 0x160) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_5 addr(base, 0x190) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_6 addr(base, 0x1C0) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_current_block_i_7 addr(base, 0x1F0) "SW could read the coordinates of the last transferred block. The status is reset when the channel is enabled (change the state of CTRL.ENABLE from 0 to 1)." {
        _ 6 mbz;
        by 10 ro "Vertical position of the last transferred 2D block in the frame.";
        _ 6 mbz;
        bx 10 ro "Horizontal position of the last transferred 2D block in the frame.";
    };
    
    register simcop_dma_chan_block_step_i_0 addr(base, 0xA4) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_1 addr(base, 0xD4) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_2 addr(base, 0x104) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_3 addr(base, 0x134) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_4 addr(base, 0x164) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_5 addr(base, 0x194) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_6 addr(base, 0x1C4) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
    
    register simcop_dma_chan_block_step_i_7 addr(base, 0x1F4) "Offset between 2D blocks." {
        _ 2 mbz;
        ystep 14 rw "Vertical offset, in lines, between rows of 2D blocks. For contiguous 2D blocks YSTEP=YNUM Valid values are -8192 to +8191.";
        _ 1 mbz;
        xstep 11 rw "Horizontal offset, in 128-bit words, between 2D block columns. For contiguous 2D blocks XSTEP=XNUM Valid values are -1024 to +1023, that corresponds to 16 bytes to 16KB.";
        _ 4 mbz;
    };
};