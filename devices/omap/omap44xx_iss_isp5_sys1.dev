/*
 * Copyright (c) 2013 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
 * Attn: Systems Group.
 */

/*
 * omap44xx_iss_isp5_sys1.dev
 *
 * DESCRIPTION: 
 *
 * NOTE: This file has been automatically generated based on the
 * XML files extracted from the TI RDT v1.0.0.4p Tool.
 * Download from here: http://www.ti.com/product/omap4460
 * This means that the file might not be optimal in terms of naming
 * conventions for constants and registers (duplicated
 * namespaces in register and device name etc.).
 * Also, because of the underlying structure from the original XML
 * it's possible that some constants appear multiple times (if they
 * have slightly different descriptions for example).
 *
 * You want to clean that up before using the files for the first time!
 */
 
device omap44xx_iss_isp5_sys1 msbfirst ( addr base ) "" {
    
    
    register isp5_revision ro addr(base, 0x0) "IP Revision Identifier (X.Y.R) Used by software to track features, bugs, and compatibility" type(uint32);
    
    register isp5_hwinfo1 addr(base, 0x4) "GENERIC PARAMETER REGISTER Information about the hardware configuration of the IP module." {
        _ 3 mbz;
        isif_rfm_line_size 13 ro "Memory line size for the data reformatter in the ISIF module.";
        _ 3 mbz;
        ipipe_line_size 13 ro "Memory line size for the IPIPE module";
    };
    
    register isp5_hwinfo2 addr(base, 0x8) "GENERIC PARAMETER REGISTER Information about the hardware configuration of the IP module." {
        _ 19 mbz;
        h3a_line_size 13 ro "Memory line size for the H3A module";
    };

    constants standbymode_status width(2) "" {
        STANDBYMODE_0 = 0 "Force-standby mode: local initiator is unconditionally placed in standby state. Backup mode, for debug only.";
        STANDBYMODE_1 = 1 "No-standby mode: local initiator is unconditionally placed out of standby state. Backup mode, for debug only.";
        STANDBYMODE_3 = 3 "Reserved";
        STANDBYMODE_2 = 2 "Smart-standby mode: local initiator standby status depends on local conditions, that is, the module's functional requirement from the initiator. IP module must not generate (initiator-related) wake-up events. Generation of the MStandby signal must be initiated by the firmware by writing .MSTANDBY = 1.";
    };

    constants softreset_status width(1) "" {
        SOFTRESET_0_w = 0 "No action";
        SOFTRESET_1_w = 1 "Initiate software reset";
        SOFTRESET_1_r = 1 "Reset (software or other) ongoing";
        SOFTRESET_0_r = 0 "Reset done, no pending action";
    };
    
    register isp5_sysconfig addr(base, 0x10) "Clock management configuration" {
        _ 26 mbz;
        standbymode 2 rw type(standbymode_status) "Configuration of the local initiator state management mode. By definition, initiator may generate read/write transaction as long as it is out of STANDBY state.";
        _ 2 mbz;
        softreset 1 rw type(softreset_status) "Software reset. The soft reset will cause the MStandby to be asserted as the reset value of the ISP5_CTRL.MSTANDBY bit is 1. After a soft reset, the software must ensure not to perform any access for 16 clock cycles (OCP-slave port frequency) after writing this bit. The OCP slave port is running at half the frequency of the functional clock. Before issuing a soft reset, the software must ensure that no more traffic is being generated by the ISP. Basically, it means that the camera module must be stopped from sending data and/or that the ISP modules are disabled. The last interrupt triggered by the ISP design upon completion of the frame processing is rsz_int_dma. This rsz_int_dma event must be used to enable clean termination of the processing. The software must wait a few hundred cycles to trigger the soft reset after upon assertion of the rsz_int_dma, this is to ensure that the BL is completely drained. Software must set the ISP in standby mode before issuing the soft reset: Set ISP5_SYSCONFIG.STANDBYMODE = 2 (smart standby). Set ISP5_CTRL.MSTANDBY to 1. Poll for ISP5_CTRL.MSTANDBY_WAIT = 1. Then, the soft reset can be applied (ISP5_SYSCONFIG.SOFTRESET = 1).";
        auto_idle 1 ro "Auto clock gating. Always enabled.";
    };

    constants ocp_err_irq_status width(1) "" {
        OCP_ERR_IRQ_0_w = 0 "No action";
        OCP_ERR_IRQ_1_w = 1 "Set event (debug)";
        OCP_ERR_IRQ_1_r = 1 "Event pending";
        OCP_ERR_IRQ_0_r = 0 "No event pending";
    };
    
    register isp5_irqstatus_raw_i_0 addr(base, 0x24) "Per-event raw interrupt status vector. Raw status is set even if event is not enabled. Write 1 to set the (raw) status, mostly for debug. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status) "This event signals that overflow happened in the input data buffering submodule. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. Depending on the mode being used, the overflow can happen at different places: 1. Bypass mode: overflow happened in the input circular buffer. 2. Pass through mode: overflow happened on the module output interface (MTC) 3. Normal resize mode: overflow happened in the input circular buffer. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status) "";
        af_int 1 rw type(ocp_err_irq_status) "";
        aew_int 1 rw type(ocp_err_irq_status) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status) "";
        isif_int_3 1 rw type(ocp_err_irq_status) "";
        isif_int_2 1 rw type(ocp_err_irq_status) "";
        isif_int_1 1 rw type(ocp_err_irq_status) "";
        isif_int_0 1 rw type(ocp_err_irq_status) "";
    };
    
    register isp5_irqstatus_raw_i_1 addr(base, 0x34) "Per-event raw interrupt status vector. Raw status is set even if event is not enabled. Write 1 to set the (raw) status, mostly for debug. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status) "This event signals that overflow happened in the input data buffering submodule. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. Depending on the mode being used, the overflow can happen at different places: 1. Bypass mode: overflow happened in the input circular buffer. 2. Pass through mode: overflow happened on the module output interface (MTC) 3. Normal resize mode: overflow happened in the input circular buffer. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status) "";
        af_int 1 rw type(ocp_err_irq_status) "";
        aew_int 1 rw type(ocp_err_irq_status) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status) "";
        isif_int_3 1 rw type(ocp_err_irq_status) "";
        isif_int_2 1 rw type(ocp_err_irq_status) "";
        isif_int_1 1 rw type(ocp_err_irq_status) "";
        isif_int_0 1 rw type(ocp_err_irq_status) "";
    };
    
    register isp5_irqstatus_raw_i_2 addr(base, 0x44) "Per-event raw interrupt status vector. Raw status is set even if event is not enabled. Write 1 to set the (raw) status, mostly for debug. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status) "This event signals that overflow happened in the input data buffering submodule. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. Depending on the mode being used, the overflow can happen at different places: 1. Bypass mode: overflow happened in the input circular buffer. 2. Pass through mode: overflow happened on the module output interface (MTC) 3. Normal resize mode: overflow happened in the input circular buffer. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status) "";
        af_int 1 rw type(ocp_err_irq_status) "";
        aew_int 1 rw type(ocp_err_irq_status) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status) "";
        isif_int_3 1 rw type(ocp_err_irq_status) "";
        isif_int_2 1 rw type(ocp_err_irq_status) "";
        isif_int_1 1 rw type(ocp_err_irq_status) "";
        isif_int_0 1 rw type(ocp_err_irq_status) "";
    };
    
    register isp5_irqstatus_raw_i_3 addr(base, 0x54) "Per-event raw interrupt status vector. Raw status is set even if event is not enabled. Write 1 to set the (raw) status, mostly for debug. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status) "This event signals that overflow happened in the input data buffering submodule. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. Depending on the mode being used, the overflow can happen at different places: 1. Bypass mode: overflow happened in the input circular buffer. 2. Pass through mode: overflow happened on the module output interface (MTC) 3. Normal resize mode: overflow happened in the input circular buffer. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status) "";
        af_int 1 rw type(ocp_err_irq_status) "";
        aew_int 1 rw type(ocp_err_irq_status) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status) "";
        isif_int_3 1 rw type(ocp_err_irq_status) "";
        isif_int_2 1 rw type(ocp_err_irq_status) "";
        isif_int_1 1 rw type(ocp_err_irq_status) "";
        isif_int_0 1 rw type(ocp_err_irq_status) "";
    };

    constants ocp_err_irq_status1 width(1) "" {
        OCP_ERR_IRQ_0_w_4 = 0 "No action";
        OCP_ERR_IRQ_1_w_4 = 1 "Clear (raw) event";
        OCP_ERR_IRQ_1_r_4 = 1 "Event pending";
        OCP_ERR_IRQ_0_r_4 = 0 "No (enabled) event pending";
    };
    
    register isp5_irqstatus_i_0 addr(base, 0x28) "Per-event 'enabled' interrupt status vector. Enabled status is not set unless event is enabled. Write 1 to clear the status after interrupt has been serviced (raw status gets cleared, that is, even if not enabled). The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status1) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status1) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        h3a_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        rsz_int_eof1 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status1) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status1) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status1) "";
        af_int 1 rw1c type(ocp_err_irq_status1) "";
        aew_int 1 rw1c type(ocp_err_irq_status1) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status1) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status1) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status1) "LSC interrupt issued by 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status1) "VD interrupt 2 event. Read this bit to check the interrupt mapped to the INT_2 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status1) "VD interrupt 1 event. Read this bit to check the interrupt mapped to the INT_1 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status1) "VD interrupt 0 event. Read this bit to check the interrupt mapped to the INT_0 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqstatus_i_1 addr(base, 0x38) "Per-event 'enabled' interrupt status vector. Enabled status is not set unless event is enabled. Write 1 to clear the status after interrupt has been serviced (raw status gets cleared, that is, even if not enabled). The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status1) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status1) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        h3a_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        rsz_int_eof1 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status1) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status1) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status1) "";
        af_int 1 rw1c type(ocp_err_irq_status1) "";
        aew_int 1 rw1c type(ocp_err_irq_status1) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status1) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status1) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status1) "LSC interrupt issued by 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status1) "VD interrupt 2 event. Read this bit to check the interrupt mapped to the INT_2 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status1) "VD interrupt 1 event. Read this bit to check the interrupt mapped to the INT_1 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status1) "VD interrupt 0 event. Read this bit to check the interrupt mapped to the INT_0 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqstatus_i_2 addr(base, 0x48) "Per-event 'enabled' interrupt status vector. Enabled status is not set unless event is enabled. Write 1 to clear the status after interrupt has been serviced (raw status gets cleared, that is, even if not enabled). The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status1) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status1) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        h3a_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        rsz_int_eof1 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status1) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status1) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status1) "";
        af_int 1 rw1c type(ocp_err_irq_status1) "";
        aew_int 1 rw1c type(ocp_err_irq_status1) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status1) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status1) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status1) "LSC interrupt issued by 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status1) "VD interrupt 2 event. Read this bit to check the interrupt mapped to the INT_2 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status1) "VD interrupt 1 event. Read this bit to check the interrupt mapped to the INT_1 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status1) "VD interrupt 0 event. Read this bit to check the interrupt mapped to the INT_0 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqstatus_i_3 addr(base, 0x58) "Per-event 'enabled' interrupt status vector. Enabled status is not set unless event is enabled. Write 1 to clear the status after interrupt has been serviced (raw status gets cleared, that is, even if not enabled). The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status1) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status1) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        h3a_int_eof 1 rw1c type(ocp_err_irq_status1) "";
        rsz_int_eof1 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status1) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status1) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status1) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status1) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status1) "";
        af_int 1 rw1c type(ocp_err_irq_status1) "";
        aew_int 1 rw1c type(ocp_err_irq_status1) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status1) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status1) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status1) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status1) "LSC interrupt issued by 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status1) "VD interrupt 2 event. Read this bit to check the interrupt mapped to the INT_2 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status1) "VD interrupt 1 event. Read this bit to check the interrupt mapped to the INT_1 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status1) "VD interrupt 0 event. Read this bit to check the interrupt mapped to the INT_0 line. This interrupt is also set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };

    constants ocp_err_irq_status2 width(1) "" {
        OCP_ERR_IRQ_0_w_8 = 0 "No action";
        OCP_ERR_IRQ_1_w_8 = 1 "Enable interrupt";
        OCP_ERR_IRQ_1_r_8 = 1 "Interrupt enabled";
        OCP_ERR_IRQ_0_r_8 = 0 "Interrupt disabled (masked)";
    };
    
    register isp5_irqenable_set_i_0 addr(base, 0x2C) "Per-event interrupt enable bit vector. Write 1 to set (enable interrupt). Readout equal to corresponding _CLR register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status2) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status2) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status2) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status2) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status2) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status2) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status2) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status2) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status2) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status2) "";
        af_int 1 rw type(ocp_err_irq_status2) "";
        aew_int 1 rw type(ocp_err_irq_status2) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status2) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status2) "";
        isif_int_3 1 rw type(ocp_err_irq_status2) "LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw type(ocp_err_irq_status2) "VD interrupt 2 event. Set this bit to enable the interrupt and map it to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw type(ocp_err_irq_status2) "VD interrupt 1 event. Set this bit to enable the interrupt and map it to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw type(ocp_err_irq_status2) "VD interrupt 0 event. Set this bit to enable the interrupt mapped to INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqenable_set_i_1 addr(base, 0x3C) "Per-event interrupt enable bit vector. Write 1 to set (enable interrupt). Readout equal to corresponding _CLR register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status2) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status2) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status2) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status2) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status2) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status2) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status2) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status2) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status2) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status2) "";
        af_int 1 rw type(ocp_err_irq_status2) "";
        aew_int 1 rw type(ocp_err_irq_status2) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status2) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status2) "";
        isif_int_3 1 rw type(ocp_err_irq_status2) "LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw type(ocp_err_irq_status2) "VD interrupt 2 event. Set this bit to enable the interrupt and map it to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw type(ocp_err_irq_status2) "VD interrupt 1 event. Set this bit to enable the interrupt and map it to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw type(ocp_err_irq_status2) "VD interrupt 0 event. Set this bit to enable the interrupt mapped to INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqenable_set_i_2 addr(base, 0x4C) "Per-event interrupt enable bit vector. Write 1 to set (enable interrupt). Readout equal to corresponding _CLR register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status2) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status2) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status2) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status2) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status2) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status2) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status2) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status2) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status2) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status2) "";
        af_int 1 rw type(ocp_err_irq_status2) "";
        aew_int 1 rw type(ocp_err_irq_status2) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status2) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status2) "";
        isif_int_3 1 rw type(ocp_err_irq_status2) "LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw type(ocp_err_irq_status2) "VD interrupt 2 event. Set this bit to enable the interrupt and map it to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw type(ocp_err_irq_status2) "VD interrupt 1 event. Set this bit to enable the interrupt and map it to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw type(ocp_err_irq_status2) "VD interrupt 0 event. Set this bit to enable the interrupt mapped to INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqenable_set_i_3 addr(base, 0x5C) "Per-event interrupt enable bit vector. Write 1 to set (enable interrupt). Readout equal to corresponding _CLR register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw type(ocp_err_irq_status2) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_rnew0 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dpc_ini 1 rw type(ocp_err_irq_status2) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status2) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status2) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw type(ocp_err_irq_status2) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw type(ocp_err_irq_status2) "This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface. This event would typically happen while processing a frame because the video port pixel clock is too high: the firmware must take care to use a lower pixel clock at the input of the resizer module. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_int_cyc_rzb 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw type(ocp_err_irq_status2) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw type(ocp_err_irq_status2) "This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw type(ocp_err_irq_status2) "This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw type(ocp_err_irq_status2) "This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw type(ocp_err_irq_status2) "";
        af_int 1 rw type(ocp_err_irq_status2) "";
        aew_int 1 rw type(ocp_err_irq_status2) "";
        ipipeif_irq 1 rw type(ocp_err_irq_status2) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_bsc 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_dma 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_last_pix 1 rw type(ocp_err_irq_status2) "";
        ipipe_int_reg 1 rw type(ocp_err_irq_status2) "";
        isif_int_3 1 rw type(ocp_err_irq_status2) "LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw type(ocp_err_irq_status2) "VD interrupt 2 event. Set this bit to enable the interrupt and map it to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw type(ocp_err_irq_status2) "VD interrupt 1 event. Set this bit to enable the interrupt and map it to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw type(ocp_err_irq_status2) "VD interrupt 0 event. Set this bit to enable the interrupt mapped to INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };

    constants ocp_err_irq_status3 width(1) "" {
        OCP_ERR_IRQ_0_w_12 = 0 "No action";
        OCP_ERR_IRQ_1_w_12 = 1 "Disable interrupt";
        OCP_ERR_IRQ_1_r_12 = 1 "Interrupt enabled";
        OCP_ERR_IRQ_0_r_12 = 0 "Interrupt disabled (masked)";
    };
    
    register isp5_irqenable_clr_i_0 addr(base, 0x30) "Per-event interrupt enable bit vector. Write 1 to clear (disable interrupt). Readout equal to corresponding _SET register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status3) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status3) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status3) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status3) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status3) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface.. This event would typically happen because the video port pixel clock is too high.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status3) "";
        af_int 1 rw1c type(ocp_err_irq_status3) "";
        aew_int 1 rw1c type(ocp_err_irq_status3) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status3) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status3) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status3) "Set this bit to disable the LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status3) "VD interrupt 2 event. Set this bit to disable the interrupt mapped to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status3) "VD interrupt 1 event. Set this bit to disable the interrupt mapped to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status3) "VD interrupt 0 event. Set this bit to disable the interrupt mapped to the INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqenable_clr_i_1 addr(base, 0x40) "Per-event interrupt enable bit vector. Write 1 to clear (disable interrupt). Readout equal to corresponding _SET register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status3) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status3) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status3) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status3) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status3) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface.. This event would typically happen because the video port pixel clock is too high.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status3) "";
        af_int 1 rw1c type(ocp_err_irq_status3) "";
        aew_int 1 rw1c type(ocp_err_irq_status3) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status3) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status3) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status3) "Set this bit to disable the LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status3) "VD interrupt 2 event. Set this bit to disable the interrupt mapped to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status3) "VD interrupt 1 event. Set this bit to disable the interrupt mapped to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status3) "VD interrupt 0 event. Set this bit to disable the interrupt mapped to the INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqenable_clr_i_2 addr(base, 0x50) "Per-event interrupt enable bit vector. Write 1 to clear (disable interrupt). Readout equal to corresponding _SET register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status3) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status3) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status3) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status3) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status3) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface.. This event would typically happen because the video port pixel clock is too high.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status3) "";
        af_int 1 rw1c type(ocp_err_irq_status3) "";
        aew_int 1 rw1c type(ocp_err_irq_status3) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status3) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status3) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status3) "Set this bit to disable the LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status3) "VD interrupt 2 event. Set this bit to disable the interrupt mapped to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status3) "VD interrupt 1 event. Set this bit to disable the interrupt mapped to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status3) "VD interrupt 0 event. Set this bit to disable the interrupt mapped to the INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };
    
    register isp5_irqenable_clr_i_3 addr(base, 0x60) "Per-event interrupt enable bit vector. Write 1 to clear (disable interrupt). Readout equal to corresponding _SET register. The ISP outputs four interrupt lines, ISP_IRQ0 to ISP_IRQ3. Any internal ISP event can be merged on the four lines. A same event must be enabled on only one interrupt line." {
        ocp_err_irq 1 rw1c type(ocp_err_irq_status3) "An OCP error has been received on the ISP master port.";
        _ 1 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_rnew0 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dpc_ini 1 rw1c type(ocp_err_irq_status3) "";
        _ 1 mbz;
        ipipe_int_eof 1 rw type(ocp_err_irq_status3) "";
        h3a_int_eof 1 rw type(ocp_err_irq_status3) "";
        rsz_int_eof1 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer B engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        rsz_int_eof0 1 rw type(ocp_err_irq_status3) "RESIZER module event: This event signals that the BL has received the EOF signal from the resizer A engine which happens one the last transfer in the frame has happened. Note that because the BL has FIFOs it may take some additional time before true data transfer completion to memory.";
        _ 2 mbz;
        rsz_fifo_in_blk_err 1 rw1c type(ocp_err_irq_status3) "This event signals that the minimum vertical blanking period has not been respected causing errors in the input data buffering submodule. This event will be triggered when the rsz_int_reg event of frame N is triggered before the rsz_int_dma of frame N + 1. This event would typically happen at the transition between two frames because there is not enough vertical blanking between frames: the firmware must take care to ensure enough vertical blanking. The hardware cannot recover from this error. It will be required to perform a reset of the IP.";
        rsz_fifo_ovf 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event signals that overflow happened in the input data buffering submodule or in the RSZ output interface.. This event would typically happen because the video port pixel clock is too high.";
        rsz_int_cyc_rzb 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #B. An event can be triggered every time that RSZ_IRQ_RZB output lines have been written out to the RZB_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, this value should be such that the circular buffer vertical size (set by the RZB_SDR_Y_PTR_E register) is a multiple of RSZ_IRQ_RZB. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_cyc_rza 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is the circular interrupt for RESIZER #A. An event can be triggered every time that RSZ_IRQ_RZA output lines have been written out to the RZA_SDR_Y buffer. The range can go from 1 to 8192 lines. Usually, the circular buffer vertical size (set by the RZA_SDR_Y_PTR_E register) should be a multiple of RSZ_IRQ_RZA. Note that at the time the interrupt is triggered, the actual data write has not taken place. It may take a few hundred of cycles to complete the data write into system memory. This is not an issue since the start of the buffer is read first.";
        rsz_int_dma 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last EOF (of the two MTC interfaces) is sent out to the BL and that the resizer core has returned to idle. rsz_int_dma is a true indication that all processing is finished for the particular frame on both resizer engines.";
        rsz_int_last_pix 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the last pixel of the valid area is received.";
        rsz_int_reg 1 rw1c type(ocp_err_irq_status3) "RESIZER module event: This event is triggered when the first pixel of the valid area is received. Shadowed registers can be updated at any time but the new value will take effect on the next rsz_int_reg event.";
        h3a_int 1 rw1c type(ocp_err_irq_status3) "";
        af_int 1 rw1c type(ocp_err_irq_status3) "";
        aew_int 1 rw1c type(ocp_err_irq_status3) "";
        ipipeif_irq 1 rw1c type(ocp_err_irq_status3) "IPIPEIF module interrupt";
        ipipe_int_hst 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_bsc 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_dma 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_last_pix 1 rw1c type(ocp_err_irq_status3) "";
        ipipe_int_reg 1 rw1c type(ocp_err_irq_status3) "";
        isif_int_3 1 rw1c type(ocp_err_irq_status3) "Set this bit to disable the LSC interrupt issued by the 2D-LSC block. Four types of 2D-LSC can be generated and mapped to the INT_3 line. For more information, see,";
        isif_int_2 1 rw1c type(ocp_err_irq_status3) "VD interrupt 2 event. Set this bit to disable the interrupt mapped to the INT_2 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_1 1 rw1c type(ocp_err_irq_status3) "VD interrupt 1 event. Set this bit to disable the interrupt mapped to the INT_1 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
        isif_int_0 1 rw1c type(ocp_err_irq_status3) "VD interrupt 0 event. Set this bit to disable the interrupt mapped to the INT_0 line. This interrupt is set based on the VD pulse position after receiving a configured number of horizontal pulse signals. For more information, see,";
    };

    constants ipipe_int_dpc_rnew1_status width(1) "" {
        IPIPE_INT_DPC_RNEW1_0_w_16 = 0 "No action";
        IPIPE_INT_DPC_RNEW1_1_w_16 = 1 "Enable DMA";
        IPIPE_INT_DPC_RNEW1_1_r_16 = 1 "DMA enabled";
        IPIPE_INT_DPC_RNEW1_0_r_16 = 0 "DMA disabled";
    };
    
    register isp5_dmaenable_set addr(base, 0x64) "Per-line DMA enable bit vector Write 1 to set (enable DMA request generation). Readout equal to corresponding _CLR register." {
        _ 27 mbz;
        ipipe_int_dpc_rnew1 1 rw type(ipipe_int_dpc_rnew1_status) "Enable for ISP DMA request generation on line #2 This DMA request must be set to transfer the DPC data from memory to the IPIPE internal RAM.";
        ipipe_int_last_pix 1 rw type(ipipe_int_dpc_rnew1_status) "Enable for ISP DMA request generation on line #3 This DMA request must be set to transfer the GAMMA data from memory to the IPIPE internal RAM or to initialize the DPC table. One must set the ISP5_CTRL.DMA3_CFG register before enabling this DMA request.";
        ipipe_int_dpc_rnew0 1 rw type(ipipe_int_dpc_rnew1_status) "Enable for ISP DMA request generation on line #2 This DMA request must be set to transfer the DPC data from memory to the IPIPE internal RAM.";
        ipipe_int_hst 1 rw type(ipipe_int_dpc_rnew1_status) "Enable for ISP DMA request generation on line #1 This DMA request must be set to transfer the HIST data from the IPIPE internal RAM to memory.";
        ipipe_int_bsc 1 rw type(ipipe_int_dpc_rnew1_status) "Enable for ISP DMA request generation on line #0 This DMA request must be set to transfer the BSC data from the IPIPE internal RAM to memory.";
    };

    constants ipipe_int_dpc_rnew1_status1 width(1) "" {
        IPIPE_INT_DPC_RNEW1_0_w_17 = 0 "No action";
        IPIPE_INT_DPC_RNEW1_1_w_17 = 1 "Disable DMA";
        IPIPE_INT_DPC_RNEW1_1_r_17 = 1 "DMA enabled";
        IPIPE_INT_DPC_RNEW1_0_r_17 = 0 "DMA disabled";
    };
    
    register isp5_dmaenable_clr addr(base, 0x68) "Per-line DMA clear bit vector Write 1 to clear (disable DMA request generation). Readout equal to corresponding _SET register." {
        _ 27 mbz;
        ipipe_int_dpc_rnew1 1 rw1c type(ipipe_int_dpc_rnew1_status1) "Clear for ISP DMA request generation on line ISS_DMA2. This DMA request must be set to transfer the DPC data from memory to the IPIPE internal RAM.";
        ipipe_int_last_pix 1 rw1c type(ipipe_int_dpc_rnew1_status1) "Clear for ISP DMA request generation on ISS_DMA3. This DMA request must be set to transfer the GAMMA data from memory to the IPIPE internal RAM.";
        ipipe_int_dpc_rnew0 1 rw1c type(ipipe_int_dpc_rnew1_status1) "Clear for ISP DMA request generation on ISS_DMA2. This DMA request must be set to transfer the DPC data from memory to the IPIPE internal RAM.";
        ipipe_int_hst 1 rw1c type(ipipe_int_dpc_rnew1_status1) "Clear for ISP DMA request generation on ISS_DMA1. This DMA request must be set to transfer the HIST data from the IPIPE internal RAM to memory.";
        ipipe_int_bsc 1 rw1c type(ipipe_int_dpc_rnew1_status1) "Clear for ISP DMA request generation on ISS_DMA0. This DMA request must be set to transfer the BSC data from the IPIPE internal RAM to memory.";
    };

    constants dma3_cfg_status width(2) "" {
        DMA3_CFG_0 = 0 "No DMA request associated with ISS_DMA3.";
        DMA3_CFG_1 = 1 "DPC DMA request associated with ISS_DMA3. Expected DMA transfer size is 2KB in the range 0x8000-0x87FF. DPC_EVT_INI must be set to 0.";
        DMA3_CFG_3 = 3 "DPC + GAMMA DMA request associated with ISS_DMA3. Expected DMA transfer size is 8KB in the range 0x8000-0x87FF and 0xA800-0xBFFF. DPC_EVT_INI must be set to 0.";
        DMA3_CFG_2 = 2 "GAMMA DMA request associated with ISS_DMA3. Expected DMA transfer size is 6KB in the range 0xA800-0xBFFF.";
    };

    constants hst_rd_chk_status width(1) "" {
        HST_RD_CHK_0_w = 0 "Clears the signal to avoid error generation. The software must write this bit to 0 after the last data read.";
        HST_RD_CHK_1_w = 1 "Reserved";
        HST_RD_CHK_1_r = 1 "The MPU can read the data from the memory. Needs to complete fast enough to avoid the interrupt generation.";
        HST_RD_CHK_0_r = 0 "No interrupt generation can happen";
    };

    constants dpc_evt_ini_status width(1) "" {
        DPC_EVT_INI_0 = 0 "IPIPE_INT_LAST_PIX event is selected.";
        DPC_EVT_INI_1 = 1 "IPIPE_INT_DPC_INI event is selected.";
    };

    constants mstandby_status width(1) "" {
        MSTANDBY_0 = 0 "De-assert MStandby signal. May not be immediate due to power management handshaking btw the MStandby and Wait signals.";
        MSTANDBY_1 = 1 "Assert MStandby signal";
    };

    constants vd_pulse_ext_status width(1) "" {
        VD_PULSE_EXT_0 = 0 "Disabled";
        VD_PULSE_EXT_1 = 1 "Enabled";
    };

    constants pclk_inv_status width(1) "" {
        PCLK_INV_0 = 0 "Normal";
        PCLK_INV_1 = 1 "Inversed";
    };

    constants mstanddby_wait_status width(1) "" {
        MSTANDDBY_WAIT_1_r = 1 "MStandby signal is asserted.";
        MSTANDDBY_WAIT_0_r = 0 "MStandby signal is deasserted.";
    };

    constants bl_clk_enable_status width(1) "" {
        BL_CLK_ENABLE_0 = 0 "Disable";
        BL_CLK_ENABLE_1 = 1 "Enable";
    };

    constants psync_clk_sel_status width(1) "" {
        PSYNC_CLK_SEL_0 = 0 "GCK_MMR. Can be used if the input pixel clock is always lower than 100 MHz.";
        PSYNC_CLK_SEL_1 = 1 "ISS_FCLK. must be used if the pixel clock is higher than 100 MHz.";
    };

    constants vbusm_cpriority_status width(3) "" {
        VBUSM_CPRIORITY_6 = 6 "Normal Priority VBUSM cpriority[2:0] = 6";
        VBUSM_CPRIORITY_1 = 1 "High Priority VBUSM cpriority[2:0] = 1";
        VBUSM_CPRIORITY_7 = 7 "Normal Priority VBUSM cpriority[2:0] = 7";
        VBUSM_CPRIORITY_0 = 0 "High Priority VBUSM cpriority[2:0] = 0";
        VBUSM_CPRIORITY_2 = 2 "Medium Priority VBUSM cpriority[2:0] = 2";
        VBUSM_CPRIORITY_4 = 4 "Normal Priority VBUSM cpriority[2:0] = 4";
        VBUSM_CPRIORITY_5 = 5 "Normal Priority VBUSM cpriority[2:0] = 5";
        VBUSM_CPRIORITY_3 = 3 "Medium Priority VBUSM cpriority[2:0] = 3";
    };

    constants ocp_wrnp_status width(1) "" {
        OCP_WRNP_0 = 0 "All writes are non posted.";
        OCP_WRNP_1 = 1 "All writes are posted.";
    };
    
    register isp5_ctrl addr(base, 0x6C) "ISP5 CONTROL REGISTER" {
        dma3_cfg 2 rw type(dma3_cfg_status) "This bit field selects the DMA transfer configuration which is used with the ISS_DMA3 DMA request signal. This DMA request is generated from IPIPE_INT_LAST_PIXEL event. One can choose to use this DMA request to transfer the DPC initialization data, the gamma table, or both.";
        _ 2 mbz;
        _ 1 mbz;
        hst_rd_chk 1 rw type(hst_rd_chk_status) "When the HISTOGRAM computation is enabled and the HST DMA request is not used to read out the data, this register ensures that the data is read fast enough, else an interruptISP5_IRQSTATUS2_i[5] IPIPE_HST_ERR is triggered. The hardware sets automatically this bit to 1 when software can start reading the memory.";
        dpc_evt_ini 1 rw type(dpc_evt_ini_status) "Select the IPIPE module event to be used to generate the DMA requests for the DPC submodule.";
        mstandby 1 rw type(mstandby_status) "MStandby signal assertion and de-assertion control for power management transitions. After software reset, this bit is asserted. Write '1' to transition from normal mode to idle mode. The firmware needs to ensure that no more ISP processing is ongoing before setting up this bit. Write '0' to transition from idle mode to normal mode. The software should poll ISP5_CTRL.MSTANDBY_WAIT = 0 after writing ISP5_CTRL.MSTANDBY = 0 in a transition from idle to normal mode.";
        vd_pulse_ext 1 rw type(vd_pulse_ext_status) "VD pulse extension enable This bit enables or disables the VD extension bridge. By default, the bridge is enabled. At ISS level, it is expected that ISP5_CTRL.VD_PULSE_EXT = 1 when the VPORT gets data from the CSI2 RX module and ISP5_CTRL.VD_PULSE_EXT = 0 when the VPORT gets data from the parallel interface or the CCP2 RX module. There must be at least three clock cycles between the time this bit is modified and the HD/VD pulse for start of frame comes.";
        pclk_inv 1 rw type(pclk_inv_status) "Pixel clock inversion This bit enables or disables pixel clock inversion. The ISP always samples the data on the rising edge of the pixel clock. Enabling the inversion shifts the resampling period by 1/2 a pixel clock period.";
        mflag 1 rw "MFlag signal generation control This bit controls how the OCP MFlag signal is generated on the ISS NOC. 0x0: The MFlag value is dynamic. 0x1: The MFlag value is static. The value is set with the ISP5_CTRL[3:1] VBUSM_CPRIORITY.";
        mstanddby_wait 1 ro type(mstanddby_wait_status) "MStandby / Wait power management status bit. The power management framework of the ISP is based on the handshaking of the MStandby and Wait signals. The software is not supposed to write inside the ISP slave port and initiate traffic when ISP5_CTRL.MSTANDBY bit is written. The software can poll this bit to know when Wait signal is deasserted.";
        _ 4 mbz;
        bl_clk_enable 1 rw type(bl_clk_enable_status) "BL clock enable";
        isif_clk_enable 1 rw type(bl_clk_enable_status) "ISIF clock enable The ISP will return OCP_ERROR if one tries to program the module MMR or memory when the clock is disabled. There must be at least three clock cycles between the time this bit is modified and the HD/VD pulse for start of frame comes.";
        h3a_clk_enable 1 rw type(bl_clk_enable_status) "H3A clock enable The ISP will return OCP_ERROR if one tries to program the module MMR or memory when the clock is disabled.";
        rsz_clk_enable 1 rw type(bl_clk_enable_status) "RESIZER clock enable The ISP will return OCP_ERROR if one tries to program the module MMR or memory when the clock is disabled.";
        ipipe_clk_enable 1 rw type(bl_clk_enable_status) "IPIPE clock enable The ISP will return OCP_ERROR if one tries to program the module MMR or memory when the clock is disabled.";
        ipipeif_clk_enable 1 rw type(bl_clk_enable_status) "IPIPEIF clock enable The ISP will return OCP_ERROR if one tries to program the module MMR or memory when the clock is disabled.";
        sync_enable 1 rw type(bl_clk_enable_status) "PCLK Sync module enable. This bit may only be modified when the video port is not receiving data such as when data is read from the IPIPEIF module memory read port.";
        psync_clk_sel 1 rw type(psync_clk_sel_status) "PCLK Sync clock select. This bit selects the clock which is used to resynchronize the input pixel clock.";
        vbusm_cids 4 rw "BL MAX VBUSM CIDs The BL module supports up to 16 CIDs/tags. This bit field sets up the maximum number of CISs/tags that the BL can use. The actual number of CIDs/tags is setup by VBUSM_CIDS + 1. Tag number 0 to VBUSM_CIDS are used.";
        vbusm_cpriority 3 rw type(vbusm_cpriority_status) "BL VBUSM priority setting";
        ocp_wrnp 1 rw type(ocp_wrnp_status) "ISP OCP master port non-posted write control.";
    };

    constants src_sel_status width(2) "" {
        SRC_SEL_0 = 0 "ISP video port is selected.";
        SRC_SEL_1 = 1 "Reserved";
        SRC_SEL_3 = 3 "Pattern generator is selected.";
        SRC_SEL_2 = 2 "Reserved";
    };

    constants en_status width(1) "" {
        EN_0 = 0 "Pattern generator off";
        EN_1 = 1 "Enable pattern generator";
    };

    constants wen_status width(1) "" {
        WEN_0 = 0 "WEN is always activated";
        WEN_1 = 1 "WEN is on 8 cycles and off 8 cycles";
    };

    constants hdpol_status width(1) "" {
        HDPOL_0 = 0 "Active high";
        HDPOL_1 = 1 "Active low";
    };
    
    register isp5_pg addr(base, 0x70) "PATTERN GENERATOR REGISTER" {
        _ 26 mbz;
        src_sel 2 rw type(src_sel_status) "Input mux selection";
        en 1 rw type(en_status) "";
        wen 1 rw type(wen_status) "";
        hdpol 1 rw type(hdpol_status) "";
        vdpol 1 rw type(hdpol_status) "";
    };
    
    register isp5_pg_pulse_ctrl addr(base, 0x74) "PATTERN GENERATOR REGISTER" {
        _ 4 mbz;
        vdw 12 rw "Pattern generator VD width Width = VDW+1";
        _ 3 mbz;
        hdw 13 rw "Pattern generator HD width Width = HDW+1";
    };
    
    register isp5_pg_frame_size addr(base, 0x78) "PATTERN GENERATOR REGISTER" {
        ppln 16 rw "Pattern Generator: pixels per line, PPLN+1";
        hlpfr 16 rw "Pattern Generator: half lines per frame, HLPFR+1";
    };

    constants ipipe_gamma_rgb_copy_status width(1) "" {
        IPIPE_GAMMA_RGB_COPY_0 = 0 "Copy disable Independent RGB gamma table";
        IPIPE_GAMMA_RGB_COPY_1 = 1 "Copy enable Common RGB Gamma table";
    };

    constants ipipe_bsc_tb1_status width(1) "" {
        IPIPE_BSC_TB1_0 = 0 "MODULE access has higher priority";
        IPIPE_BSC_TB1_1 = 1 "CPU access has higher priority.";
    };

    constants isif_lsc_tb1_status width(1) "" {
        ISIF_LSC_TB1_0 = 0 "MODULE has memory access When the module has memory access, the potential concurrent CPU accesses (on the ISP memory map) to read the memory are stalled. The CPU will eventually get back the data during the horizontal or vertical blanking periods when the module is not making access anymore.";
        ISIF_LSC_TB1_1 = 1 "CPU has memory access When the CPU has memory access (read or write), it will cause data corruption if the module tries to perform concurrent memory accesses. The module cannot know that the read or write access has not taken place because of CPU accesses.";
    };
    
    register isp5_mpsr addr(base, 0x7C) "ISP memory access register. One need to pay attention when setting the bit fields in this register such that there is no conflict between the CPU and module accesses. Usually, the ISP modules must have access to the memories and it is only when the ISP is idle (vertical blanking period or module disabled that the CPU can access the memories." {
        _ 7 mbz;
        ipipe_gamma_rgb_copy 1 rw type(ipipe_gamma_rgb_copy_status) "GAMMA table RGB Copy This bit must be enable when one wants to use the same Gamma table for the R, G and B color components. When the CPU writes the R table, it is automatically copied to the G and B tables if this bit is set.";
        _ 3 mbz;
        ipipe_bsc_tb1 1 rw type(ipipe_bsc_tb1_status) "IPIPE BSC TB1 memory access priority This memory is expected to be read by the CPU or the DMA to get BSC information during vertical blanking period.";
        ipipe_bsc_tb0 1 rw type(ipipe_bsc_tb1_status) "IPIPE BSC TB0 memory access priority This memory is expected to be read by the CPU or the DMA to get BSC information during vertical blanking period.";
        ipipe_hst_tb3 1 rw type(ipipe_bsc_tb1_status) "IPIPE histogram memory #3 access priority This memory is expected to be read by the CPU or the DMA to get HST information during vertical blanking period.";
        ipipe_hst_tb2 1 rw type(ipipe_bsc_tb1_status) "IPIPE histogram memory #2 access priority This memory is expected to be read by the CPU or the DMA to get HST information during vertical blanking period.";
        ipipe_hst_tb1 1 rw type(ipipe_bsc_tb1_status) "IPIPE histogram memory #1 access priority This memory is expected to be read by the CPU or the DMA to get HST information during vertical blanking period.";
        ipipe_hst_tb0 1 rw type(ipipe_bsc_tb1_status) "IPIPE histogram memory #0 access priority This memory is expected to be read by the CPU or the DMA to get HST information during vertical blanking period.";
        ipipe_d3l_tb3 1 rw type(ipipe_bsc_tb1_status) "D3L TB3 memory access priority This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_d3l_tb2 1 rw type(ipipe_bsc_tb1_status) "D3L TB2 memory access priority This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_d3l_tb1 1 rw type(ipipe_bsc_tb1_status) "D3L TB1 memory access priority This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_d3l_tb0 1 rw type(ipipe_bsc_tb1_status) "D3L TB0 memory access priority This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_gbc_tb 1 rw type(ipipe_bsc_tb1_status) "IPIPE GBC TB memory access priority This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_yee_tb 1 rw type(ipipe_bsc_tb1_status) "YEE TB memory access priority This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_gmm_tbr 1 rw type(ipipe_bsc_tb1_status) "IPIPE Gamma LUT R memory arbitration This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_gmm_tbg 1 rw type(ipipe_bsc_tb1_status) "IPIPE Gamma LUT G memory arbitration This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_gmm_tbb 1 rw type(ipipe_bsc_tb1_status) "IPIPE Gamma LUT B memory arbitration This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        ipipe_dpc_tb 1 rw type(ipipe_bsc_tb1_status) "IPIPE defect pixel memory arbitration This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        isif_dclamp 1 rw type(ipipe_bsc_tb1_status) "ISIF DC accumulation memory arbitration This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        isif_lsc_tb1 1 rw type(isif_lsc_tb1_status) "ISIF LSC memory 1 access This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        isif_lsc_tb0 1 rw type(isif_lsc_tb1_status) "ISIF LSC memory 0 access This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        isif_lin_tb 1 rw type(ipipe_bsc_tb1_status) "ISIF linearity compensation memory arbitration This memory is expected to be written during ISP initialization and potentially updated during vertical blanking periods.";
        _ 1 mbz;
    };
    
    register isp5_bl_mtc_1 addr(base, 0x80) "MEMORY REQUEST MINIMUM INTERVAL REGISTER" {
        isif_r 16 rw "Sets the minimum interval btw two consecutive memory requests for the ISIF-Read port. Specified in number of interface clock cycles.";
        ipipeif_r 16 rw "Sets the minimum interval btw two consecutive memory requests for the IPIPEIF-Read port. Specified in number of interface clock cycles.";
    };
    
    register isp5_bl_mtc_2 addr(base, 0x84) "MEMORY REQUEST MINIMUM INTERVAL REGISTER" {
        h3a_w 16 rw "Sets the minimum interval btw two consecutive memory requests for the H3A-Write port. Specified in number of interface clock cycles.";
        _ 16 mbz;
    };

    constants mflag_thres_status width(1) "" {
        MFLAG_THRES_0 = 0 "Thres = 1";
        MFLAG_THRES_1 = 1 "Thres = 3";
    };
    
    register isp5_bl_vbusm addr(base, 0x88) "BL VBUSM TUNING REGISTER The settings in the register are static and not expected to be modified dynamically." {
        _ 26 mbz;
        mflag_thres 1 rw type(mflag_thres_status) "MFLAG Threshold value The value of this bit field is a threshold which is compared to the MFlag output of the ISP5. If the BL MFlag signal is greater or equal to this threshold the last beat of the VBUSM command is delayed by ISP5_BL_VBUSM[4:0] LASTCMD_DLY cycles. Only values 0, 1 are valid, the least significant bit is tied off to 1 to make a 2-bit field.";
        lastcmd_dly 5 rw "The value of this bit field represents a delay expressed in cycles (L3 clock). This value is used to delay the last beat of the VBUSM command such that the ISP does not loose arbitration at the ISS level because the BL does not generate back to back requests by default. The last beat is delayed until the counter expires or the new request is accepted. This delay is used when the MFlag output of the ISP is greater or equal to ISP5_BL_VBUSM[5] MFLAG_THRES. One can set this value to 0 to disable the last command beat delay.";
    };
};