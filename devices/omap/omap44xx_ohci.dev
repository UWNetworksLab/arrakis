/*
 * Copyright (c) 2013 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
 * Attn: Systems Group.
 */

/*
 * omap44xx_ohci.dev
 *
 * DESCRIPTION: 
 *
 * NOTE: This file has been automatically generated based on the
 * XML files extracted from the TI RDT v1.0.0.4p Tool.
 * Download from here: http://www.ti.com/product/omap4460
 * This means that the file might not be optimal in terms of naming
 * conventions for constants and registers (duplicated
 * namespaces in register and device name etc.).
 * Also, because of the underlying structure from the original XML
 * it's possible that some constants appear multiple times (if they
 * have slightly different descriptions for example).
 *
 * You want to clean that up before using the files for the first time!
 */
 
device omap44xx_ohci msbfirst ( addr base ) "" {
    
    
    register hcrevision addr(base, 0x0) "OHCI revision number" {
        _ 24 mbz;
        rev 8 ro "OHCI specification revision the OHCI revision number upon which the USB host controller is based. Examples: 0x10 for 1.0, 0x21 for 2.1";
    };

    constants ir_status width(1) "" {
        IR_0 = 0 "All interrupts are routed to the normal host bus interrupt mechanism..";
        IR_1 = 1 "Interrupts are routed to the system management Interrupt.";
    };

    constants hcfs_status width(2) "" {
        HCFS_0 = 0 "HCFS: USB reset";
        HCFS_1 = 1 "HCFS: USB resume";
        HCFS_2 = 2 "HCFS: USB operational";
        HCFS_3 = 3 "HCFS: USB suspend";
    };

    constants ble_status width(1) "" {
        BLE_0 = 0 "Bulk ED list is not processed after the next SOF.";
        BLE_1 = 1 "Enables processing of bulk ED list in the next frame.";
    };

    constants ie_status width(1) "" {
        IE_0 = 0 "Isochronous EDs are not processed.";
        IE_1 = 1 "Enables processing of isochronous EDs";
    };

    constants ple_status width(1) "" {
        PLE_0 = 0 "Periodic ED lists are not processed after the next frame.";
        PLE_1 = 1 "Enables processing of periodic ED lists in the next frame.";
    };

    constants cbsr_status width(2) "" {
        CBSR_0 = 0 "One control ED per bulk ED";
        CBSR_1 = 1 "Two control ED per bulk ED";
        CBSR_2 = 2 "Three control ED per bulk ED";
        CBSR_3 = 3 "Four control ED per bulk ED";
    };
    
    register hccontrol addr(base, 0x4) "HC operating mode register" {
        _ 21 mbz;
        rwe 1 rw "Remote wake-up enableThis bit is used to enable or disable the remote wakeup feature upon detection of upstream resume signaling. .";
        rwc 1 rw "Remote wake-up connected.This bit indicates whether the host controller supports remote wakeup signaling. .";
        ir 1 rw type(ir_status) "Interrupt routingThis bit determines the routing of interrupts generated by events registered in. .";
        hcfs 2 rw type(hcfs_status) "Host controller functional state";
        ble 1 rw type(ble_status) "Bulk list processing enable";
        cle 1 rw type(ble_status) "Control list processing enable";
        ie 1 rw type(ie_status) "Isochronous ED processing enabled by host controller driver";
        ple 1 rw type(ple_status) "Periodic list enable";
        cbsr 2 rw type(cbsr_status) "Control/bulk service ratio. Specifies the ratio between control and bulk EDs processed in a frame.";
    };

    constants hcr_status width(1) "" {
        HCR_0 = 0 "No effect";
        HCR_1 = 1 "USB host controller is reset.";
    };
    
    register hccommandstatus addr(base, 0x8) "HC command and status" {
        _ 14 mbz;
        soc 2 ro "Scheduling overrun countThis is used to monitor any persistent scheduling problems. . These bits are incremented on each scheduling overrun error. It is initialized to 0x0 and wraps around at 0x3. .";
        _ 12 mbz;
        ocr 1 rw "Ownership change request.This bit is set to request a change of control of the host controller. .";
        blf 1 rw "Bulk list filledThis bit is used to indicate whether there are any TDs on the bulk list. It is set whenever it adds a TD to an ED in the bulk list. .";
        clf 1 rw "Control list filledThis bit is used to indicate whether there are any TDs on the control list. It is set whenever it adds a TD to an ED in the control list. .";
        hcr 1 rw type(hcr_status) "Host controller reset (software reset). Set this bit to initiate a USB host controller reset. This resets most USB host controller OHCI registers. OHCI register accesses must not be attempted until a read of this register returns a 0.";
    };

    constants oc_status width(1) "" {
        OC_1_r = 1 "An ownership change has occurred.";
        OC_0_w = 0 "No effect";
        OC_1_w = 1 "Clears this bit";
    };
    
    register hcinterruptstatus addr(base, 0xC) "HC interrupt status" {
        _ 1 mbz;
        oc 1 ro type(oc_status) "Ownership changeThis bit is set when the[3] OCR bit is set. .";
        _ 23 mbz;
        rhsc 1 rw "Root hub status change When 0x1: A root hub status change has occurred. Write 0x0: No effect Write 0x1: Clears this bit";
        fno 1 rw "Frame number overflow When 0x1: A frame number overflow has occurred. Write 0x0: No effect Write 0x1: Clears this bit";
        ue 1 rw "Unrecoverable error When 0x1: An unrecoverable error has occurred. Write 0x0: No effect Write 0x1: Clears this bit";
        rd 1 rw "Resume detected When 0x1: A downstream device has issued a resume request. Write 0x0: No effect Write 0x1: Clears this bit";
        sf 1 rw "Start of frame When 0x1: A SOF has been issued. Write 0x0: No effect Write 0x1: Clears this bit";
        wdh 1 rw "Write done head When 0x1: The USB host controller has updated the HCDONEHEAD register. Write 0x0: No effect Write 0x1: Clears this bit";
        so 1 rw "Scheduling overrun When 0x1: A scheduling overrun has occurred. Write 0x0: No effect Write 0x1: Clears this bit";
    };

    constants oc_status1 width(1) "" {
        OC_0_w_1 = 0 "No effect";
        OC_1_w_1 = 1 "Enable interrupt generation due to ownership change.";
    };
    
    register hcinterruptenable addr(base, 0x10) "HC interrupt enable" {
        mie 1 rw "Master interrupt enable When 0x1: Allows other enabled OHCI interrupt sources to propagate to the device interrupt controller When 0x0: OHCI interrupt sources are ignored. Write 0x0: No effect Write 0x1: Sets this bit";
        oc 1 rw type(oc_status1) "Ownership change";
        _ 23 mbz;
        rhsc 1 rw "Root hub status change When 0x1 and MIE is 0x1: Allows root hub status change interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: Root hub status change interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
        fno 1 rw "Frame number overflow When 0x1 and MIE is 0x1: Allows FNO interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: FNO interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
        ue 1 rw "Unrecoverable error When 0x1 and MIE is 0x1: Allows UE interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: UE interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
        rd 1 rw "Resume detected When 0x1 and MIE is 0x1: Allows RD interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: RD interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
        sf 1 rw "Start of frame When 0x1 and MIE is 0x1: Allows SF interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: SF interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
        wdh 1 rw "Write done head When 0x1 and MIE is 0x1: Allows WDH interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: WDH interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
        so 1 rw "Scheduling overrun When 0x1 and MIE is 0x1: Allows SO interrupts to propagate to the device interrupt controller When 0x0 or MIE is 0x0: SO interrupts do not propagate. Write 0x0: No effect Write 0x1: Sets this bit";
    };

    constants oc_status2 width(1) "" {
        OC_0_w_2 = 0 "No effect.";
        OC_1_w_2 = 1 "Disable interrupt generation due to ownership change.";
    };
    
    register hcinterruptdisable addr(base, 0x14) "HC interrupt disable" {
        mie 1 rw "Master interrupt enable Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE MIE bit";
        oc 1 rw type(oc_status2) "Ownership change.";
        _ 23 mbz;
        rhsc 1 rw "Root hub status change Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE RHSC bit";
        fno 1 rw "Frame number overflow Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE FNO bit";
        ue 1 rw "Unrecoverable error Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE UE bit";
        rd 1 rw "Resume detected Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE RD bit";
        sf 1 rw "Start of frame Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE SF bit";
        wdh 1 rw "Write done head Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE WDH bit";
        so 1 rw "Scheduling overrun Always reads 0x0. Write 0x0: No effect Write 0x1: Clears the HCINTERRUPTENABLE SO bit";
    };
    
    register hchcca addr(base, 0x18) "HC HCCA address register" {
        hcca 24 rw "Physical address of the beginning of the HCCA";
        _ 8 mbz;
    };
    
    register hcperiodcurrented addr(base, 0x1C) "HC current periodic register" {
        pced 28 ro "Physical address of current ED on the periodic ED list";
        _ 4 mbz;
    };
    
    register hccontrolheaded addr(base, 0x20) "HC head control register" {
        ched 28 rw "Physical address of head ED on the control ED list";
        _ 4 mbz;
    };
    
    register hccontrolcurrented addr(base, 0x24) "HC current control register" {
        cced 28 rw "Physical address of current ED on the control ED list";
        _ 4 mbz;
    };
    
    register hcbulkheaded addr(base, 0x28) "HC head bulk register" {
        bhed 28 rw "Physical address of head ED on the bulk ED list";
        _ 4 mbz;
    };
    
    register hcbulkcurrented addr(base, 0x2C) "HC current bulk register" {
        bced 28 rw "Physical address of current ED on the bulk ED list";
        _ 4 mbz;
    };
    
    register hcdonehead addr(base, 0x30) "HC head done register" {
        dh 28 ro "Physical address of last TD that was added to the Done queue";
        _ 4 mbz;
    };
    
    register hcfminterval addr(base, 0x34) "HC frame interval register" {
        fit 1 rw "Frame interval toggleThis bit is toggled whenever it loads a new value to FI. .";
        fsmps 15 rw "Largest data packet size for full-speed packets, bit timesThis field specifies a value which is loaded into the largest data packet counter at the beginning of each frame. .";
        _ 2 mbz;
        fi 14 rw "Frame interval. Number of 12-MHz clocks in the USB frame. The nominal value is set to 11,999, to give a 1-ms frame.";
    };
    
    register hcfmremaining addr(base, 0x38) "HC frame remaining register" {
        frt 1 ro "Frame remaining toggleThis bit is used for the synchronization between[13:0] FI and FR. . This bit is loaded from the[31] FIT bit whenever FR reaches 0. .";
        _ 17 mbz;
        fr 14 ro "Frame remainingThis counter is decremented at each bit time. When it reaches 0, it is reset by loading the value of the USBHOST.[13:0] FI bit field at the next bit time boundary. .";
    };
    
    register hcfmnumber addr(base, 0x3C) "HC frame number register" {
        _ 16 mbz;
        fn 16 ro "Frame numberThis is incremented when is reloaded. It is rolled over to 0x0000 after 0xFFFF. .";
    };
    
    register hcperiodicstart addr(base, 0x40) "HC periodic start register" {
        _ 18 mbz;
        ps 14 rw "Periodic start. The host controller driver must program this value to be about 10 percent less than the frame interval field value so that control and bulk EDs have priority for the first 10 percent of the frame; then periodic EDs have priority for the remaining 90 percent of the frame.";
    };
    
    register hclsthreshold addr(base, 0x44) "HC low-speed threshold register" {
        _ 20 mbz;
        lst 12 rw "Low-speed threshold";
    };

    constants nocp_status width(1) "" {
        NOCP_0 = 0 "Overcurrent status is reported collectively for all downstream ports.";
        NOCP_1 = 1 "The USB host controller does not implement overcurrent protection inputs.";
    };

    constants nps_status width(1) "" {
        NPS_0 = 0 "VBUS power switching is supported, either per-port or all-port switched per the power.";
        NPS_1 = 1 "VBUS power switching is not supported; power is available to all downstream ports.";
    };
    
    register hcrhdescriptora addr(base, 0x48) "HC root hub A register" {
        potpg 8 rw "Power-on to power-good time. Defines the minimum amount of time (2 ms * POTPG) between the USB host controller turning on power to a downstream port and when the USB host can access the downstream device.";
        _ 11 mbz;
        nocp 1 rw type(nocp_status) "No overcurrent protection. This function is not supported at the device level.";
        ocpm 1 rw "Overcurrent protection mode. This function is not supported at the device level.";
        dt 1 ro "Device type Always reads 0x0: Indicates that the USB host controller implemented is not a compound device.";
        nps 1 rw type(nps_status) "No power switching";
        psm 1 rw type(ir_status) "Power switching mode";
        ndp 8 ro "Number of downstream ports These bits specify the number of downstream ports supported by the root hub. It is implementation-specific. The minimum number of ports is 1. The maximum number of ports supported by OHCI is 15.";
    };
    
    register hcrhdescriptorb addr(base, 0x4C) "HC root hub B register" {
        ppcm 16 rw "Port power control mask. Each bit defines whether a corresponding downstream port has port power controlled by the global power control. When set, the port's power state is only affected by per-port power control. When cleared, the port is controlled by the global power switch. If the device is configured to global switch mode this field is not valid. Bit 0: Reserved, bit 1: Ganged-power mask on port 1, ..., bit 15: Ganged-power mask on port 15.";
        dr 16 rw "Device removable. Each bit defines whether a corresponding downstream port has a removable device. When cleared, the attached device is removable. When set, the attached device is not removable. Bit 0: Reserved, bit 1: Device attached to port 1,... , bit 15: Device attached to port 15.";
    };
    
    register hcrhstatus addr(base, 0x50) "HC root hub status register" {
        crwe 1 wo "Clear remote wakeup enable Write 0x0: No effect Write 0x1: Clears the device remote wake-up enable bit";
        _ 14 mbz;
        lpsc 1 rw "Local power status change Always reads 0x0: The root hub does not support the local power status feature. Write 0x0: No effect Write 0x1: Sets port power status bits for all ports, if power switching mode is 0. Sets port power status bits for ports with their corresponding port power control mask bits cleared if power switching mode is 1.";
        drwe 1 rw "Device remote wake-up enable. Enables a connect status change event as a resume event, causing a USB suspend to USB resume state transition and sets the resume detected interrupt status bit. Read 0x1: Connect status change is a remote wake-up event. Read 0x0: Connect status change is not a remote wake-up event. Write 0x0: No effect Write 0x1: Sets the device remote wake-up enable bit";
        _ 14 mbz;
        lps 1 rw "Local power status Always reads 0x0 Write 0x0: No effect Write 0x1: When in global power mode (power switching mode = 0), turns off power to all ports. If in per-port power mode (power switching mode = 1), turns of power to those ports whose corresponding port power control mask bit is 0.";
    };

    constants pssc_status width(1) "" {
        PSSC_0_w = 0 "No effect";
        PSSC_0_r = 0 "No resume completed (since either the last software clear, or the last port reset).";
        PSSC_1_r = 1 "Resume completed on the port";
        PSSC_1_w = 1 "Clears the bit";
    };
    
    register hcrhportstatus_1 addr(base, 0x54) "HC port 1 status and control register" {
        _ 11 mbz;
        prsc 1 rw "Port 1 reset status change. This bit is set when the port 1 port reset status bit has changed. Write 0x0: No effect Write 0x1: Clears this bit";
        _ 1 mbz;
        pssc 1 rw type(pssc_status) "Port 1 suspends status change. Set when the port leaves the suspend state; that is, after the full resume sequence has completed.";
        pesc 1 rw "Port 1 enable status change. This bit is set when the port 1 port enable status has changed. Write 0x0: No effect Write 0x1: Clears this bit";
        csc 1 rw "Port 1 connect status change. This bit is set when the port1 port current connect status has changed due to a connect or disconnect event. If current connect status is 0 when a set port reset, set port enable, or set port suspend write occurs, this bit is set. Write 0x0: No effect Write 0x1: Clears this bit If the HCRHDESCRIPTORB[1] DR bit is set, this bit is set only after a root hub reset to inform the system that the device is attached.";
        _ 6 mbz;
        lsda_cpp 1 rw "Port 1 low-speed device attached/clear port power. This bit is valid only when port 1 current connect status is 1. Read 0x0: A full-speed device is attached to port 1. Read 0x1: A low-speed device is attached to port 1. Write 0x0: No effect Write 0x1: Clears the port 1 port power status";
        pps_spp 1 rw "Port 1 port power status/set port power Read 0x0: Port 1 power is enabled. Read 0x1: Port 1 power is not enabled. Write 0x0: No effect Write 0x1: Sets the port 1 port power status bit";
        _ 3 mbz;
        prs_spr 1 rw "Port 1 port reset status/set port reset Read 0x0: USB reset is not being sent to port 1. Read 0x1: Port 1 is signaling the USB reset. Write 0x0: No effect Write 0x1: Sets the port 1 port reset status bit and causes the USB host controller to begin signaling USB reset to port 1";
        _ 1 mbz;
        pss_sps 1 rw "Port 1 port suspend status/set port suspend. This bit is cleared automatically at the end of the USB resume sequence and also at the end of the USB reset sequence. Write 0x0: No effect Read 0x0: Port 1 is not in the USB suspend state. Read 0x1: Port 1 is in the USB suspend state or is in the resume sequence. Write 0x1: If port 1 current connect status is 1, sets the port 1 port suspend status bit and places port 1 in USB suspend state. If current connect status is 0, sets instead connect status change to inform the USB host controller driver of an attempt to suspend a disconnected port.";
        pes_spe 1 rw "Port 1 port enable status/set port enable. This bit is automatically set at completion of port 1 USB reset if it was not already set before the USB reset completed, and is automatically set at the end of a USB suspend if the port was not enabled when the USB resume completed. Read 0x0: Port 1 is not enabled. Read 0x1: Port 1 is enabled. Write 0x0: No effect Write 0x1: When port 1 current connect status is 1 sets the port 1 port enable status bit. When port 1 current status is 0 has no effect.";
        ccs_cpe 1 rw "Port 1 current connection status/clear port enable Read 0x0: No USB device is attached to port 1. Read 0x1: A USB device is currently attached to port 1. Write 0x0: No effect Write 0x1: Clears the port 1 port enable bit Note: This bit is set to 1 if the HCRHDESCRIPTORB[1 DR bit] is set to indicate a nonremovable device on port 1.";
    };

    constants pssc_status1 width(1) "" {
        PSSC_0_w_1 = 0 "No effect";
        PSSC_0_r_1 = 0 "No resume completed (since either the last software clear, or the last port reset).";
        PSSC_1_r_1 = 1 "Resume completed on the port.";
        PSSC_1_w_1 = 1 "Clears the bit";
    };
    
    register hcrhportstatus_2 addr(base, 0x58) "HC port 2 status and control register" {
        _ 11 mbz;
        prsc 1 rw "Port 2 reset status change. This bit is set when the port 2 port reset status bit has changed. Write 0x0: No effect Write 0x1: Clears this bit";
        _ 1 mbz;
        pssc 1 rw type(pssc_status1) "Port 2 suspend status change. Set when the port leaves the suspend state; that is, after the full resume sequence has completed.";
        pesc 1 rw "Port 2 enable status change. This bit is set when the port 2 port enable status has changed. Write 0x0: No effect Write 0x1: Clears this bit";
        csc 1 rw "Port 2 connect status change. This bit is set when the port 2 port current connect status has changed due to a connect or disconnect event. If current connect status is 0 when a set port reset, set port enable, or set port suspend write occurs, this bit is set. Write 0x0: No effect Write 0x1: Clears this bit If the HCRHDESCRIPTORB[1] DR bit is set, this bit is set only after a root hub reset to inform the system that the device is attached.";
        _ 6 mbz;
        lsda_cpp 1 rw "Port 2 low-speed device attached/clear port power. This bit is valid only when port 2 current connect status is 1. Read 0x0: A full-speed device is attached to port 2. Read 0x1: A low-speed device is attached to port 2. Write 0x0: No effect Write 0x1: Clears the port 2 port power status";
        pps_spp 1 rw "Port 2 port power status/set port power Read 0x0: Port 2 power is enabled. Read 0x1: Port 2 power is not enabled. Write 0x0: No effect Write 0x1: Sets the port 2 port power status bit";
        _ 3 mbz;
        prs_spr 1 rw "Port 2 port reset status/set port reset Read 0x0: USB reset is not being sent to port 2. Read 0x1: Port 2 is signaling the USB reset. Write 0x0: No effect Write 0x1: Sets the port 2 port reset status bit and causes the USB host controller to begin signaling USB reset to port 2";
        _ 1 mbz;
        pss_sps 1 rw "Port 2 port suspend status/set port suspend. This bit is cleared automatically at the end of the USB resume sequence and also at the end of the USB reset sequence. Write 0x0: No effect Read 0x0: Port 2 is not in the USB suspend state. Read 0x1: Port 2 is in the USB suspend state or is in the resume sequence. Write 0x1: If port 2 current connect status is 1, sets the port 2 port suspend status bit and places port 2 in USB suspend state. If current connect status is 0, sets instead connect status change to inform the USB host controller driver of an attempt to suspend a disconnected port.";
        pes_spe 1 rw "Port 2 port enable status/set port enable. This bit is automatically set at completion of port 2 USB reset if it was not already set before the USB reset completed, and is automatically set at the end of a USB suspend if the port was not enabled when the USB resume completed. Read 0x0: Port 2 is not enabled. Read 0x1: Port 2 is enabled. Write 0x0: No effect Write 0x1: When port 2 current connect status is 1 sets the port 2 port enable status bit. When port 2 current status is 0 has no effect.";
        ccs_cpe 1 rw "Port 2 current connection status/clear port enable Read 0x0: No USB device is attached to port 2. Read 0x1: A USB device is currently attached to port 2. Write 0x0: No effect Write 0x1: Clears the port 2 port enable bit This bit is set to 1 if the HCRHDESCRIPTORB[1] DR bit is set to indicate a nonremovable device on port 2.";
    };
};